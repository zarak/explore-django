## Brief Comparison of `django-admin startproject` and `minimal.py`

The entire code of `minimal.py` file follows

```python
import sys

from django.conf import settings
from django.conf.urls import url
from django.core.management import execute_from_command_line
from django.http import HttpResponse

settings.configure(
    DEBUG=True,
    SECRET_KEY='A-random-secret-key!',
    ROOT_URLCONF=sys.modules[__name__],
)


def index(request):
    return HttpResponse('<h1>A minimal Django response!</h1>')

urlpatterns = [
    url(r'^$', index),
]

if __name__ == '__main__':
    execute_from_command_line(sys.argv)
```

This is the minimum setup required in order to run a server and get a response
via Django. There are, of course, many things missing compared to the default settings generated by the Django
`startproject` command.

The `minimal.py` setup contains all the necessary functionality in a single
file. 

`startproject` on the other hand generates several files with the following
directory structure:
```
.
├── db.sqlite3
├── manage.py
└── project_name
    ├── __init__.py
    ├── settings.py
    ├── urls.py
    └── wsgi.py
```

When you add an app, you get some additional files under the project directory.
```
└── app_name 
    ├── __init__.py
    ├── admin.py
    ├── apps.py
    ├── migrations
    │   └── __init__.py
    ├── models.py
    ├── tests.py
    └── views.py
```

Going back to the `minimal.py` file, we see that only three options are
configured in the settings:
```python
settings.configure(
    DEBUG=True,
    SECRET_KEY='A-random-secret-key!',
    ROOT_URLCONF=sys.modules[__name__],
)
```

The notable option here is the `ROOT_URLCONF` setting. In the default Django
setup, this is set to have the value `'{{ project_name }}.urls'`. In
`minimal.py`, however, the option is set to treat the `minimal.py` file as the
`urls` module. This instructs Django to look here for the `urls` list, and
indeed, we see the `urlpatterns` list contained within the file.

The `urlpatterns` list contains a pairs or strings and callables. The `url`
method maps the string to a callable, in this case the `index` function in the
file. A url is pattern matched using regular expressions. The caret symbol `^`
denotes the beginning of the input, and the `$` symbol denotes the end.
Therefore, the pattern `^$` matches an empty string. So if no url is entered,
the `index` view is called by the `url` function in the `urlpatterns` list.

Next, we note the following snippet:
```python
if __name__ == '__main__':
    execute_from_command_line(sys.argv)
```

This allows `minimal.py` to behave like `manage.py` in regular Django, which is
where the same `execute_from_command_line()` function is called.

The default django setup creates a `views.py` file which contains the following
code upon creating an app with `manage.py startapp`:

```python
from django.shortcuts import render
from django import HttpResponse

# Create your views here.
def index(request):
    return HttpResponse("Hello, world. You're at the polls index.")
```

I believe `render` uses Django's default templating engine. There is also the
option to use Jinja2. In a minimal setup, one can simply use `HttpResponse`
as the response object to display on a web-page.

Django uses an ORM by default, but in a minimal setup one can use `SQLAlchemy`
or perhaps even raw SQL queries to interact with a database.

Next steps:
Add a database record in sqlite and use SQLAlchemy to access the information
and display it via a view.
